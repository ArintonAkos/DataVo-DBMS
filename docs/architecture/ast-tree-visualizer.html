<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AST Tree Visualizer</title>
  <style>
    body { font-family: Inter, system-ui, Arial, sans-serif; margin: 0; background: #0f172a; color: #e2e8f0; }
    .wrap { display: grid; grid-template-columns: 420px 1fr; height: 100vh; }
    .panel { padding: 16px; border-right: 1px solid #1e293b; background: #111827; }
    textarea { width: 100%; height: 58vh; background: #0b1220; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; padding: 12px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    button { margin-top: 10px; background: #2563eb; color: white; border: none; border-radius: 8px; padding: 10px 14px; cursor: pointer; }
    button:hover { background: #1d4ed8; }
    .hint { font-size: 12px; color: #94a3b8; line-height: 1.4; margin-top: 10px; }
    .canvas-wrap { overflow: auto; padding: 20px; }
    svg text { fill: #e2e8f0; font-size: 12px; }
    .node { fill: #1e293b; stroke: #60a5fa; stroke-width: 1.2; }
    .edge { stroke: #94a3b8; stroke-width: 1.2; }
    .error { color: #f87171; margin-top: 10px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h2>AST JSON</h2>
      <textarea id="jsonInput">{
  "type": "BinaryExpressionNode",
  "operator": "AND",
  "left": {
    "type": "BinaryExpressionNode",
    "operator": ">=",
    "left": { "type": "ResolvedColumnRefNode", "tableName": "Employees", "column": "Salary" },
    "right": { "type": "LiteralNode", "value": 90000 }
  },
  "right": {
    "type": "BinaryExpressionNode",
    "operator": "=",
    "left": { "type": "ResolvedColumnRefNode", "tableName": "Employees", "column": "DeptId" },
    "right": { "type": "LiteralNode", "value": 1 }
  }
}</textarea>
      <button id="renderBtn">Render Tree</button>
      <div class="hint">
        Supported keys: <b>type</b>, <b>operator</b>, <b>left</b>, <b>right</b>, <b>value</b>, <b>tableName</b>, <b>column</b>, <b>tableOrAlias</b>.
      </div>
      <div id="error" class="error"></div>
    </div>
    <div class="canvas-wrap">
      <svg id="svg" width="1600" height="1000"></svg>
    </div>
  </div>

  <script>
    const svg = document.getElementById('svg');
    const input = document.getElementById('jsonInput');
    const error = document.getElementById('error');

    function labelOf(node) {
      if (!node) return 'null';
      const t = node.type || 'Node';
      if (t === 'BinaryExpressionNode') return `${t}\n${node.operator || '?'}`;
      if (t === 'LiteralNode') return `${t}\n${JSON.stringify(node.value)}`;
      if (t === 'ResolvedColumnRefNode') return `${t}\n${node.tableName}.${node.column}`;
      if (t === 'ColumnRefNode') return `${t}\n${node.tableOrAlias ? node.tableOrAlias + '.' : ''}${node.column || ''}`;
      return t;
    }

    function buildTree(node) {
      if (!node) return null;
      const n = { node, left: null, right: null, x: 0, y: 0 };
      if (node.left) n.left = buildTree(node.left);
      if (node.right) n.right = buildTree(node.right);
      return n;
    }

    function layout(root) {
      let nextX = 40;
      const levelH = 110;

      function walk(n, depth) {
        if (!n) return;
        walk(n.left, depth + 1);
        n.x = nextX;
        n.y = 60 + depth * levelH;
        nextX += 220;
        walk(n.right, depth + 1);

        if (n.left && n.right) {
          n.x = (n.left.x + n.right.x) / 2;
        }
      }

      walk(root, 0);
    }

    function draw(root) {
      while (svg.firstChild) svg.removeChild(svg.firstChild);

      function edge(x1, y1, x2, y2) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1); line.setAttribute('y1', y1);
        line.setAttribute('x2', x2); line.setAttribute('y2', y2);
        line.setAttribute('class', 'edge');
        svg.appendChild(line);
      }

      function nodeBox(n) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', n.x - 90);
        rect.setAttribute('y', n.y - 28);
        rect.setAttribute('rx', 8);
        rect.setAttribute('width', 180);
        rect.setAttribute('height', 56);
        rect.setAttribute('class', 'node');
        g.appendChild(rect);

        const label = labelOf(n.node).split('\n');
        label.forEach((line, i) => {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', n.x);
          text.setAttribute('y', n.y - 4 + i * 16);
          text.setAttribute('text-anchor', 'middle');
          text.textContent = line;
          g.appendChild(text);
        });

        svg.appendChild(g);
      }

      function walk(n) {
        if (!n) return;
        if (n.left) edge(n.x, n.y + 28, n.left.x, n.left.y - 28);
        if (n.right) edge(n.x, n.y + 28, n.right.x, n.right.y - 28);
        walk(n.left);
        walk(n.right);
        nodeBox(n);
      }

      walk(root);
    }

    function render() {
      error.textContent = '';
      try {
        const json = JSON.parse(input.value);
        const root = buildTree(json);
        layout(root);
        draw(root);
      } catch (e) {
        error.textContent = e.message;
      }
    }

    document.getElementById('renderBtn').addEventListener('click', render);
    render();
  </script>
</body>
</html>
